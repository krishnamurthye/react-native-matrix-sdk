diff --git a/rust_modules/matrix-rust-sdk/bindings/matrix-sdk-ffi/src/client.rs b/rust_modules/matrix-rust-sdk/bindings/matrix-sdk-ffi/src/client.rs
index 1234567..abcdefg 100644
--- a/rust_modules/matrix-rust-sdk/bindings/matrix-sdk-ffi/src/client.rs
+++ b/rust_modules/matrix-rust-sdk/bindings/matrix-sdk-ffi/src/client.rs
@@ -14,6 +14,17 @@ use matrix_sdk::{
     ruma::{
         api::client::{
             discovery::{
+        events::{
+            call::{
+                answer::OriginalSyncCallAnswerEvent,
+                candidates::OriginalSyncCallCandidatesEvent,
+                hangup::OriginalSyncCallHangupEvent,
+                invite::OriginalSyncCallInviteEvent,
+                reject::OriginalSyncCallRejectEvent,
+                SessionDescription,
+            },
+            room::{
                 discover_homeserver::RtcFocusInfo,
                 get_authorization_server_metadata::v1::Prompt as RumaOidcPrompt,
             },
@@ -119,6 +130,7 @@ use crate::{
         AccountDataEvent, AccountDataEventType, AuthData, InviteAvatars, MediaPreviewConfig,
         MediaPreviews, MediaSource, RoomAccountDataEvent, RoomAccountDataEventType,
     },
+    voip::{CallEventListener, CallType, IceCandidate},
     runtime::get_runtime_handle,
     sync_service::{SyncService, SyncServiceBuilder},
     task_handle::TaskHandle,
@@ -1670,6 +1682,113 @@ impl Client {
             }
         }))))
     }
+
+    /// Add a global listener for VoIP call events
+    /// This is critical for P2P calls where the receiver might not have a timeline open
+    ///
+    /// The listener will receive all call events (invite, answer, candidates, hangup, etc.)
+    /// even when the app is in background or no room is open
+    pub async fn add_call_event_listener(
+        &self,
+        listener: Box<dyn CallEventListener>,
+    ) -> Result<Arc<TaskHandle>, ClientError> {
+        let client = self.inner.clone();
+        let listener = Arc::new(listener);
+
+        // Handle m.call.invite events - critical for incoming calls
+        let invite_listener = listener.clone();
+        let invite_client = client.clone();
+        let _invite_handle = invite_client.add_event_handler(
+            move |event: OriginalSyncCallInviteEvent, room: matrix_sdk::Room| {
+                let listener = invite_listener.clone();
+                async move {
+                    // Extract SDP from offer
+                    let offer_sdp = event.content.offer.sdp.clone();
+
+                    listener.on_invite(
+                        room.room_id().to_string(),
+                        event.content.call_id.to_string(),
+                        event.sender.to_string(),
+                        offer_sdp,
+                        CallType::Voice, // TODO: Extract actual call type from event when available
+                        1, // TODO: Extract version when API is available
+                    );
+                }
+            },
+        );
+
+        // Handle m.call.answer events
+        let answer_listener = listener.clone();
+        let answer_client = client.clone();
+        let _answer_handle = answer_client.add_event_handler(
+            move |event: OriginalSyncCallAnswerEvent, room: matrix_sdk::Room| {
+                let listener = answer_listener.clone();
+                async move {
+                    // Extract SDP from answer
+                    let answer_sdp = event.content.answer.sdp.clone();
+
+                    listener.on_answer(
+                        room.room_id().to_string(),
+                        event.content.call_id.to_string(),
+                        event.sender.to_string(),
+                        answer_sdp,
+                    );
+                }
+            },
+        );
+
+        // Handle m.call.candidates events - critical for P2P NAT traversal
+        let candidates_listener = listener.clone();
+        let candidates_client = client.clone();
+        let _candidates_handle = candidates_client.add_event_handler(
+            move |event: OriginalSyncCallCandidatesEvent, room: matrix_sdk::Room| {
+                let listener = candidates_listener.clone();
+                async move {
+                    // Convert candidates to our FFI type
+                    let candidates: Vec<IceCandidate> = event
+                        .content
+                        .candidates
+                        .into_iter()
+                        .map(|c| IceCandidate {
+                            candidate: c.candidate,
+                            sdp_mid: c.sdp_mid,
+                            sdp_m_line_index: c.sdp_m_line_index.map(|_| 0), // TODO: Extract actual value when API is available
+                        })
+                        .collect();
+
+                    listener.on_candidates(
+                        room.room_id().to_string(),
+                        event.content.call_id.to_string(),
+                        event.sender.to_string(),
+                        candidates,
+                    );
+                }
+            },
+        );
+
+        // Handle m.call.hangup events
+        let hangup_listener = listener.clone();
+        let hangup_client = client.clone();
+        let _hangup_handle = hangup_client.add_event_handler(
+            move |event: OriginalSyncCallHangupEvent, room: matrix_sdk::Room| {
+                let listener = hangup_listener.clone();
+                async move {
+                    listener.on_hangup(
+                        room.room_id().to_string(),
+                        event.content.call_id.to_string(),
+                        event.sender.to_string(),
+                        Some(event.content.reason.to_string()),
+                    );
+                }
+            },
+        );
+
+        // Return a composite task handle
+        Ok(Arc::new(TaskHandle::new(get_runtime_handle().spawn(async move {
+            // Keep the handlers alive until cancelled
+            futures_util::future::pending::<()>().await;
+        }))))
+    }
 }

 #[matrix_sdk_ffi_macros::export(callback_interface)]